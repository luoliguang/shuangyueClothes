# 成为WEB前端大佬的必经之路
> 从免费课程白嫖过来的笔记，整理一下，方便自己复习

## **事件循环**

### **浏览器的进程模型**

浏览器一运行就会开启多个进程。如浏览器进程、网络进程、渲染进程。一个进程可以运行多个线程，线程与线程之间可以相互通信。主要为了独立，不影响到别的运行。减少了崩溃几率。在渲染进程中又着重了解了渲染主线程。

### **渲染主线程**

它真的很忙，需要它处理的任务包括但不限于：

1.  解析HTML
2.  解析CSS
3.  计算样式
4.  布局
5.  处理图层
6.  每秒把页面画 60 次
7.  执行全局 JS 代码
8.  执行事件处理函数
9.  执行计时器的回调函数
10. ......

因为有太多任务的存在，又不能让浏览器忙得不可开交，所以浏览器想了一个办法（就像人执行任务时候的四象限一样，分优先级）。所以浏览器也有一个功能：<font color="#02fd6b">**排队**</font>

## **异步**
### **浏览器执行JS输出顺序**
1.  全局
2.  微队列 -> Promise（优先级最高）
3.  延时队列 -> 最低
4.  交互队列 -> 高
## **Promise**

解释：立即将一个函数放入微队列

```javascript
Promise.resolve().then(fn) 
```

## **如何理解 JS 的异步？（浏览器永不阻塞）**

- 单线程是异步产生的原因；
- 事件循环是异步实现的方式；

JS是一门单线程的语言，这是因为它运行在浏览器的渲染主线程中，而渲染主线程只有一个。并且渲染主线程承载着诸多的工作，渲染页面、执行JS都在其中运行。

如果使用同步的方式，就极有可能导致主线程产生阻塞，从而导致消息对列中的很多其他任务无法得到执行，这样一来，一方面会导致繁忙的主线程白白的消耗时间，另一方面导致页面无法及时更新，给用户造成卡死现象。所以浏览器采用异步的方式来避免。具体做法是当某些任务发生时，比如计时器、网络、事件监听，主线程将任务交给其他线程去处理，自身立即结束任务的执行，转而执行后续代码。当其他线程完成时，将事先传递的回调函数包装成任务，加入到消息队列的末尾排队，等待主线程调度执行。  

在这种异步模式下，浏览器永不阻塞，从而最大限度的保证了单线程的流畅运行。

## **JS中的计时器能做到精准计时吗？为什么？**

**<font color="#02fd6b">不行，因为：</font>**

1.  计算机硬件没有原子钟，无法做到精准计时；
2.  操作系统的计时函数本身就有少量偏差 ，由于JS的计时器最终调用的是操作系统的函数，也就携带了这些偏差；
3.  按照 W3C 的标准，浏览器实现计时器时，如果嵌套层级超过5层，则会带有4毫秒的最少时间，这样在计时时间少于4毫秒时又带来了偏差；
4.  手事件循环的影响，计时器的回调函数只能在主线程空闲时运行，因此又带来了偏差。

## **JS 的事件循环**

事件循环又叫做消息循环，是浏览器渲染主线程的工作方式。

在**Chrome**的源码中，它开启一个不会结束的**for**循环，每次循环从消息队列中取出第一个任务执行，而其它线程只需要在合适的时候将任务加入对列末尾即可。

过去把消息对列简单分为宏对列和微对列。这种说法目前已无法满足复杂的浏览器环境，取而代之的是一种更加灵活多变的处理方式。

根据 W3C 官方的解释，每个任务有不同的类型，同类型的任务必须在同一个对列，不同的任务可以属于不同的对列。不同任务对列有不同的优先级，在一次事件循环中，由浏览器自行决定哪一个对列的任务。但浏览器必须有一个微对列，微对列的任务具有最高的优先级，必须优先调度执行。

